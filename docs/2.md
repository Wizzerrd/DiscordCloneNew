# Part 2 ‚Äì Cognito, Express Backend, and Environment Integration

This section covers:
1. Creating **Cognito user pools** for dev and prod.
2. Creating an **Express backend** for local testing.
3. Deploying the backend using **AWS App Runner (manual console)**.
4. Updating **frontend environment variables** and **GitHub Actions** to integrate with the backend.

---

## üß© Step 1: Create Cognito User Pools (Dev & Prod)

### 1.1 Prepare `cognito-stack.yml`
Create a new CloudFormation file `infra/cognito-stack.yml`:

```yaml
AWSTemplateFormatVersion: "2010-09-09"
Description: DiscordClone Cognito authentication stack (multi-environment ready)

Parameters:
  Environment:
    Type: String
    AllowedValues: [dev, prod]
    Description: Deployment environment (e.g., dev or prod)

  FrontendDomain:
    Type: String
    Default: ""
    Description: CloudFront domain for production callbacks (this is ignored in dev)

Conditions:
  IsProd: !Equals [!Ref Environment, "prod"]
  HasFrontendDomain: !Not [!Equals [!Ref FrontendDomain, ""]]

Resources:
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub "discordclone-userpool-${Environment}"
      AutoVerifiedAttributes: [email]
      UsernameAttributes: [email]
      Schema:
        - Name: email
          Required: true
          Mutable: false

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub "discordclone-client-${Environment}"
      UserPoolId: !Ref UserPool
      GenerateSecret: false
      AllowedOAuthFlows: ["code", "implicit"]
      AllowedOAuthScopes: ["email", "openid", "profile"]
      AllowedOAuthFlowsUserPoolClient: true
      CallbackURLs:
        - !If
          - IsProd
          - !Sub "https://${FrontendDomain}/callback"
          - http://localhost:5173/callback
      LogoutURLs:
        - !If
          - IsProd
          - !Sub "https://${FrontendDomain}"
          - http://localhost:5173
      SupportedIdentityProviders: [COGNITO]
      
  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      Domain: !Sub "discordclone-auth-${Environment}-${AWS::AccountId}"
      UserPoolId: !Ref UserPool

Outputs:
  Environment:
    Value: !Ref Environment
    Description: Environment name for this Cognito stack

  UserPoolId:
    Value: !Ref UserPool
    Description: Cognito User Pool ID

  UserPoolClientId:
    Value: !Ref UserPoolClient
    Description: Cognito App Client ID

  UserPoolDomain:
    Value: !Sub "https://discordclone-auth-${Environment}-${AWS::AccountId}.auth.${AWS::Region}.amazoncognito.com"
    Description: Hosted Cognito login domain URL
```

### 1.2 Deploy Dev and Prod Pools
Run these commands from your project root:

```bash
aws cloudformation deploy \
  --template-file cognito-stack.yml \
  --stack-name discordclone-auth-dev \
  --parameter-overrides Environment=dev \
  --capabilities CAPABILITY_NAMED_IAM

aws cloudformation deploy \
  --template-file cognito-stack.yml \
  --stack-name discordclone-auth-prod \
  --parameter-overrides Environment=prod \
  --capabilities CAPABILITY_NAMED_IAM
```

Take note of the outputs:
- `UserPoolId`
- `UserPoolClientId`

You‚Äôll plug these into both frontend and backend environment files.

---

## ‚öôÔ∏è Step 2: Create Express Backend for Local Development

Create a new folder `backend/` and initialize:

```bash
mkdir backend && cd backend
npm init -y
npm install express cors dotenv jsonwebtoken jwk-to-pem jwks-rsa node-fetch
```

### `index.js`

```js
import express from 'express';
import cors from 'cors';
import { verifyCognitoToken } from './verifyCognitoToken.js';
import dotenv from 'dotenv';
dotenv.config();

const allowedOrigins = process.env.ALLOWED_ORIGINS
    if (!origin) return callback(null, true);
    ? process.env.ALLOWED_ORIGINS.split(",").map(o => o.trim())
    : ["http://localhost:5173"];

const app = express();

app.use(
    cors({
        origin: function (origin, callback) {
            if (allowedOrigins.includes(origin)) return callback(null, true);
            return callback(new Error("CORS: Not allowed"));
        },
        credentials: true,
    })
);

app.get("/health", (req, res) => res.status(200).send("OK"));

app.get('/api/protected', async (req, res) => {
    const authHeader = req.headers.authorization;
    if (!authHeader) return res.status(401).json({ message: 'Missing token' });

    const token = authHeader.split(' ')[1];

    try {
        const decoded = await verifyCognitoToken(token);
        res.json({ message: 'Token verified successfully!', user: decoded });
    } catch {
        res.status(403).json({ message: 'Invalid or expired token' });
    }
});

app.listen(8000, () => console.log('‚úÖ Backend running on port 8000'));
```

### verifyCognitoToken.js

```js
import jwt from 'jsonwebtoken';
import jwkToPem from 'jwk-to-pem';
import fetch from 'node-fetch';
import dotenv from 'dotenv';
dotenv.config();

const region = process.env.COGNITO_REGION;
const userPoolId = process.env.COGNITO_POOL_ID;
const issuer = `https://cognito-idp.${region}.amazonaws.com/${userPoolId}`;

let pems = null;

async function getPems() {
    if (pems) return pems;
    const url = `${issuer}/.well-known/jwks.json`;
    const res = await fetch(url);
    const { keys } = await res.json();
    pems = {};
    keys.forEach((key) => {
        pems[key.kid] = jwkToPem(key);
    });
    return pems;
}

export async function verifyCognitoToken(token) {
    try {
        const decoded = jwt.decode(token, { complete: true });
        const pems = await getPems();
        const pem = pems[decoded.header.kid];
        if (!pem) throw new Error('Invalid token');
        return jwt.verify(token, pem, { issuer });
    } catch (err) {
        console.error('Token verification error:', err.message);
        throw new Error('Invalid token');
    }
}
```

### `.env`
```
NODE_ENV=dev
PORT=8000
COGNITO_REGION=us-west-1
COGNITO_POOL_ID=us-west-1_XXXXXXX
COGNITO_CLIENT_ID=xxxxxxxxxxxxxxxxxxxxxx
ALLOWED_ORIGINS=http://localhost:5173
```

Add the start script to your **package.json**

```json
{
  "type": "module",
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "jsonwebtoken": "^9.0.2",
    "jwk-to-pem": "^2.0.7",
    "jwks-rsa": "^3.2.0",
    "node-fetch": "^3.3.2"
  }
}
```

Run locally:
```bash
npm start
```

---

## üöÄ Step 3: Deploy Express Backend via AWS App Runner Console

We‚Äôll deploy using the **console** for simplicity (no CloudFormation).

Before beginning this section make sure you have pushed your changes to the main branch.

App Runner may not be available in the region of the rest of your project. This is not an issue. Simply change the region in the console on the App Runner page and continue. I am using us-west-2

1. Push your backend to GitHub (in its own repo or subfolder).
2. Go to **AWS App Runner** ‚Üí ‚ÄúCreate service‚Äù.
3. Choose **Source code repository** ‚Üí Connect your GitHub account.
4. Select your repo and branch (I am using main), and code directory (backend).
5. Build settings:
   - Runtime: Node.js 18
   - Build command: `npm install`
   - Start command: `npm start`
6. Environment variables:
    ```
    NODE_ENV=production
    PORT=8000
    COGNITO_REGION=us-west-1
    COGNITO_POOL_ID=us-west-1_XXXXXXX
    COGNITO_CLIENT_ID=xxxxxxxxxxxxxxxxxxxxxx
    ALLOWED_ORIGINS=http://localhost:5173
    ```
7. Deploy.

When it‚Äôs live, note the **service URL**, e.g.:
```
https://your-app-runner-service-id.us-east-1.awsapprunner.com
```

---

## üß† Step 4: Update Frontend to Use Environment Variables

### 4.1 `.env.development` and `.env.production`

In your Next.js frontend project:

```
VITE_COGNITO_DOMAIN=https://discordclone-auth-dev-**********.auth.us-west-1.amazoncognito.com
VITE_API_BASE_URL=http://localhost:8000
VITE_COGNITO_CLIENT_ID=**********
VITE_REDIRECT_URI=http://localhost:5173/callback
```

In your GitHub repo:
- Go to **Settings ‚Üí Secrets/Variables ‚Üí Actions**
- Add the following repository environment variables:

```
VITE_COGNITO_DOMAIN=https://discordclone-auth-prod-**********.auth.us-west-1.amazoncognito.com
VITE_API_BASE_URL=https://your-app-runner-service-id.us-east-1.awsapprunner.com
VITE_COGNITO_CLIENT_ID=********
VITE_REDIRECT_URI=https://**********.cloudfront.net
```

---

## Step 5: Update Frontend Pages to create the Auth Flow.

### Create the App Router (src/App.js)

```js
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import Callback from './pages/Callback';
import Dashboard from './pages/Dashboard';
import Home from './pages/Home';

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/callback" element={<Callback />} />
        <Route path="/dashboard" element={<Dashboard />} />
      </Routes>
    </Router>
  );
}

export default App;
```

### Create Callback, Dashboard, and Home Pages

#### src/pages/Callback.jsx
```js
import { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';

export default function Callback() {
    const navigate = useNavigate();

    useEffect(() => {
        const hash = window.location.hash.substring(1);
        const params = new URLSearchParams(hash);

        const idToken = params.get('id_token');
        const accessToken = params.get('access_token');
        const expiresIn = params.get('expires_in');

        if (idToken && accessToken) {
            localStorage.setItem('id_token', idToken);
            localStorage.setItem('access_token', accessToken);
            localStorage.setItem('expires_in', expiresIn);
            console.log('‚úÖ Tokens stored:', { idToken, accessToken, expiresIn });

            // Clear hash before redirecting (to avoid re-triggering)
            window.location.hash = '';
            navigate('/dashboard', { replace: true });
        } else {
            // Only warn if tokens are *not already* in storage (prevents double log)
            if (!localStorage.getItem('id_token')) {
                console.error('‚ùå No tokens found in URL');
                navigate('/', { replace: true });
            }
        }
    }, [navigate]);

    return (
        <div style={{ textAlign: 'center', marginTop: '3rem' }}>
            <h2>Signing you in...</h2>
        </div>
    );
}
```

#### src/pages/Dashboard.jsx
```js
import { useEffect, useState } from 'react';

export default function Dashboard() {
    const [user, setUser] = useState(null);
    const [error, setError] = useState(null);

    // ‚úÖ Read API base URL from environment variable (fallback to localhost)
    const API_BASE = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000';

    useEffect(() => {
        const idToken = localStorage.getItem('id_token');

        if (!idToken) {
            setError('No token found. Please log in again.');
            return;
        }

        async function verifyToken() {
            try {
                const res = await fetch(`${API_BASE}/api/protected`, {
                    headers: { Authorization: `Bearer ${idToken}` },
                });

                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                setUser(data.user);
            } catch (err) {
                console.error('Token verification failed:', err);
                setError('Token invalid or expired. Please log in again.');
            }
        }

        verifyToken();
    }, [API_BASE]);

    if (error)
        return (
            <div style={{ textAlign: 'center', marginTop: '3rem' }}>
                <h2>‚ö†Ô∏è {error}</h2>
            </div>
        );

    if (!user)
        return (
            <div style={{ textAlign: 'center', marginTop: '3rem' }}>
                <h2>Loading user info...</h2>
            </div>
        );

    return (
        <div style={{ maxWidth: 600, margin: '3rem auto', textAlign: 'center' }}>
            <h1>Welcome üëã</h1>
            <p>
                <strong>User ID:</strong> {user.sub}
            </p>
            <p>
                <strong>Email:</strong> {user.email || '(no email claim)'}
            </p>
            <button
                onClick={() => {
                    localStorage.clear();
                    window.location.href = '/';
                }}
            >
                Log out
            </button>
        </div>
    );
}
```

#### src/pages/Home.jsx
```js
export default function Home() {
    // Pull from Vite env vars (set these in .env.local for dev)
    const cognitoDomain = import.meta.env.VITE_COGNITO_DOMAIN;
    const clientId = import.meta.env.VITE_COGNITO_CLIENT_ID;
    const redirectUri = import.meta.env.VITE_REDIRECT_URI || 'http://localhost:5173/callback';

    const loginUrl = `${cognitoDomain}/login?client_id=${clientId}&response_type=token&scope=email+openid+profile&redirect_uri=${encodeURIComponent(
        redirectUri
    )}`;

    const handleLogin = () => {
        window.location.href = loginUrl;
    };

    return (
        <div style={{ textAlign: 'center', marginTop: '5rem' }}>
            <h1>DiscordClone üîê</h1>
            <p>Log in to continue</p>
            <button onClick={handleLogin}>Login with Cognito</button>
        </div>
    );
}
```

### Test dev Auth Flow

With the dev Cognito Pool in place and the Express server running locally, run the Vite frontend service locally with ***npm run start***. Ensure that you are able to create a user and log in, log out, and log back in using the same user credentials.

## üîß Step 5: Update `deploy-frontend.yml` and redeploy the frontend

Add the new environment variables to your GitHub Actions deploy pipeline:

```yaml
    # ‚úÖ Inject all environment variables for Vite build
    - name: Create .env file
    run: |
        echo "VITE_API_BASE_URL=${{ vars.VITE_API_BASE_URL }}" >> frontend/.env
        echo "VITE_COGNITO_CLIENT_ID=${{ vars.VITE_COGNITO_CLIENT_ID }}" >> frontend/.env
        echo "VITE_COGNITO_DOMAIN=${{ vars.VITE_COGNITO_DOMAIN }}" >> frontend/.env
        echo "VITE_REDIRECT_URI=${{ vars.VITE_REDIRECT_URI }}" >> frontend/.env
```

Push your changes to main and ensure that the Github Action begins and deploys your frontend service. If the action does not trigger automatically you can manually trigger a re-run.

---

## ‚úÖ Step 6: Test the Full Flow

1. Visit your frontend (CloudFront URL).
2. Sign in through Cognito UI.
3. Fetch a token and test the `/secure` endpoint via `fetch()`.

Example:
```js
const res = await fetch(`${import.meta.env.VITE_API_BASE_URL}/secure`, {
  headers: { Authorization: `Bearer ${idToken}` },
});
```

---

